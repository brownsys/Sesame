use sesame::context::{Context, ContextData};
use sesame::pcon::PCon;
use sesame::policy::{AnyPolicy, Reason};

use crate::rocket::{
    PConRequest, PConResponder, PConResponse, PConResponseResult, ResponsePConJson,
};
use rocket::serde::json::Json;
use serde_json::{Map, Value};
use sesame::error::SesameResult;
use sesame::extensions::{ExtensionContext, SesameExtension};
use std::collections::HashMap;

// Check the policy then return value as JSON if successful.
struct JsonResponsePolicyCheck {}
impl<'a> SesameExtension<Box<OutputPConValue>, AnyPolicy, Box<OutputPConValue>>
    for JsonResponsePolicyCheck
{
    fn apply(&mut self, data: Box<OutputPConValue>, _policy: AnyPolicy) -> Box<OutputPConValue> {
        data
    }
}

// Wrapper around serde_json::Value generated by our types and consumed during responses.
pub enum OutputPConValue {
    Value(Value),
    PCon(PCon<Box<OutputPConValue>, AnyPolicy>),
    Array(Vec<OutputPConValue>),
    Object(HashMap<String, OutputPConValue>),
}
impl OutputPConValue {
    // Not public, not exposed to applications.
    fn transform(self, context: &ExtensionContext) -> SesameResult<Value> {
        match self {
            OutputPConValue::PCon(pcon) => {
                let mut ext = JsonResponsePolicyCheck {};
                let value = pcon.checked_extension(&mut ext, context, Reason::Response)?;
                value.transform(context)
            }
            OutputPConValue::Value(value) => Ok(value),
            OutputPConValue::Array(vec) => {
                let mut v = Vec::with_capacity(vec.len());
                for val in vec {
                    v.push(val.transform(context)?);
                }
                Ok(Value::Array(v))
            }
            OutputPConValue::Object(map) => {
                let mut m = Map::with_capacity(map.len());
                for (key, val) in map {
                    m.insert(key, val.transform(context)?);
                }
                Ok(Value::Object(m))
            }
        }
    }
}

// Endpoints can return (T: FromPConJson, Context) which Sesame eventually turns into
// T after a policy check.
pub struct JsonResponse<T: ResponsePConJson, D: ContextData>(pub T, pub Context<D>);
impl<T: ResponsePConJson, D: ContextData> From<(T, Context<D>)> for JsonResponse<T, D> {
    fn from((json, context): (T, Context<D>)) -> Self {
        Self(json, context)
    }
}

impl<'a, 'r, 'o: 'r, T: ResponsePConJson, D: ContextData> PConResponder<'a, 'r, 'o>
    for JsonResponse<T, D>
{
    fn respond_to(self, request: PConRequest<'a, 'r>) -> PConResponseResult<'o> {
        let (json, context) = (self.0, self.1);
        let context = ExtensionContext::new(context);
        match json.to_json().transform(&context) {
            Err(err) => err.respond_to(request),
            Ok(json) => {
                let result =
                    rocket::response::Responder::respond_to(Json(json), request.get_request())?;
                Ok(PConResponse::new(result))
            }
        }
    }
}
