use sesame::bbox::BBox;
use sesame::context::{Context, ContextData};
use sesame::policy::{AnyPolicy, Reason};

use crate::rocket::{
    BBoxRequest, BBoxResponder, BBoxResponse, BBoxResponseResult, ResponseBBoxJson,
};
use rocket::serde::json::Json;
use serde_json::{Map, Value};
use sesame::error::SesameResult;
use sesame::extensions::{ExtensionContext, SesameExtension};
use std::collections::HashMap;

// Check the policy then return value as JSON if successful.
struct JsonResponsePolicyCheck {}
impl<'a> SesameExtension<Box<OutputBBoxValue>, AnyPolicy, Box<OutputBBoxValue>>
    for JsonResponsePolicyCheck
{
    fn apply(&mut self, data: Box<OutputBBoxValue>, _policy: AnyPolicy) -> Box<OutputBBoxValue> {
        data
    }
}

// Wrapper around serde_json::Value generated by our types and consumed during responses.
pub enum OutputBBoxValue {
    Value(Value),
    BBox(BBox<Box<OutputBBoxValue>, AnyPolicy>),
    Array(Vec<OutputBBoxValue>),
    Object(HashMap<String, OutputBBoxValue>),
}
impl OutputBBoxValue {
    // Not public, not exposed to applications.
    fn transform(self, context: &ExtensionContext) -> SesameResult<Value> {
        match self {
            OutputBBoxValue::BBox(bbox) => {
                let mut ext = JsonResponsePolicyCheck {};
                let value = bbox.checked_extension(&mut ext, context, Reason::Response)?;
                value.transform(context)
            }
            OutputBBoxValue::Value(value) => Ok(value),
            OutputBBoxValue::Array(vec) => {
                let mut v = Vec::with_capacity(vec.len());
                for val in vec {
                    v.push(val.transform(context)?);
                }
                Ok(Value::Array(v))
            }
            OutputBBoxValue::Object(map) => {
                let mut m = Map::with_capacity(map.len());
                for (key, val) in map {
                    m.insert(key, val.transform(context)?);
                }
                Ok(Value::Object(m))
            }
        }
    }
}

// Endpoints can return (T: FromBBoxJson, Context) which Sesame eventually turns into
// T after a policy check.
pub struct JsonResponse<T: ResponseBBoxJson, D: ContextData>(pub T, pub Context<D>);
impl<T: ResponseBBoxJson, D: ContextData> From<(T, Context<D>)> for JsonResponse<T, D> {
    fn from((json, context): (T, Context<D>)) -> Self {
        Self(json, context)
    }
}

impl<'a, 'r, 'o: 'r, T: ResponseBBoxJson, D: ContextData> BBoxResponder<'a, 'r, 'o>
    for JsonResponse<T, D>
{
    fn respond_to(self, request: BBoxRequest<'a, 'r>) -> BBoxResponseResult<'o> {
        let (json, context) = (self.0, self.1);
        let context = ExtensionContext::new(context);
        match json.to_json().transform(&context) {
            Err(err) => err.respond_to(request),
            Ok(json) => {
                let result =
                    rocket::response::Responder::respond_to(Json(json), request.get_request())?;
                Ok(BBoxResponse::new(result))
            }
        }
    }
}
