use rustc_lint::LateContext;
use rustc_span::def_id::DefId;

use clippy_utils::get_trait_def_id;
use clippy_utils::diagnostics::span_lint_and_help;

use std::vec::Vec;

declare_sesame_lint!(
    /// ### What it does
    /// Denies manual implementations of SesameSandbox

    /// ### Why is this bad?
    /// Developers could leak information as it is getting serialized to pass to sandbox

    /// ### Example
    /// ```rust
    /// // impl SesameSandbox for SomeStruct { ... }
    /// ```
    /// Use instead:
    /// ```rust
    /// // #[SesameSandbox()]
    /// // pub fn sandbox_function(arg: Type) -> Type  { ... }    /// ```
    pub SESAME_SANDBOX,
    Deny, // does not allow override
    "SesameSandbox must always be auto-generated by SesameSandbox, not user-implemented",
    check_crate(cx: &LateContext<'_>)
);

// Check if def_id has the doc attribute we use to detect derived implementations.
fn contains_secret(cx: &LateContext<'_>, def_id: &DefId) -> bool {
    let secret = "Library implementation of SesameSandbox. Do not copy this docstring!";
    cx.tcx.get_attr(*def_id, rustc_span::symbol::Symbol::intern("doc"))
        .and_then(|attr| Some(attr.doc_str().unwrap().to_ident_string()))
        .and_then(|doc| Some(doc.contains(secret)))
        .unwrap_or(false)
}

// Display an error message for offending def_id.
fn error_message(cx: &LateContext<'_>, &def_id: &DefId) {
    let map: rustc_middle::hir::map::Map = cx.tcx.hir();
    match map.span_if_local(def_id.clone()) {
        None => {
            panic!("Manual implementation of SesameSandbox trait at {}. doc: {:?}",
                   cx.tcx.def_path_str(def_id),
                   cx.tcx.get_attr(def_id, rustc_span::symbol::Symbol::intern("doc")));
        },
        Some(span) => {
            span_lint_and_help (
                cx,
                SESAME_SANDBOX,
                span,
                "\x1b[93mmanual implementation of SesameSandbox trait\x1b[0m",
                None, "use `#[SesameSandbox()]` instead"
            );
        }
    }
}

// Lint implementation
fn check_crate(cx: &LateContext<'_>) {
    let path: &[&str] = &vec!["sesame_sandbox", "SesameSandbox"];
    let def_id = get_trait_def_id(cx, path);
    if def_id.is_none() {
        // Compiling some dependency that does not link with Sesame.
        return;
    }

    let nested_trait_impls = cx.tcx.trait_impls_of(def_id.unwrap());
    let trait_impls = nested_trait_impls.non_blanket_impls()
        .iter().fold(Vec::new(), |mut acc, (_, v)| { acc.extend(v.iter()); acc });
    trait_impls.iter()
        .filter(|def_id| 
            !contains_secret(cx, def_id) 
            && def_id.krate == rustc_hir::def_id::LOCAL_CRATE)
        .for_each(|def_id| {
            error_message(cx, def_id);
    });
}


#[test]
fn sesame_sandbox_legal() {
    dylint_testing::ui_test_example(
        env!("CARGO_PKG_NAME"),
        "sesame_sandbox_legal"
    );
}

#[test]
fn sesame_sandbox_illegal() {
    dylint_testing::ui_test_example(
        env!("CARGO_PKG_NAME"),
        "sesame_sandbox_illegal"
    );
}
