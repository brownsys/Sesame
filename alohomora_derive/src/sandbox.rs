extern crate proc_macro2;
extern crate quote;
extern crate syn;

use proc_macro2::{Span, TokenStream};
use quote::{quote, quote_spanned, ToTokens};
use syn::{parse::Parser, DeriveInput, FnArg, Ident, ItemFn, ReturnType};
// use ::alohomora_sandbox::alloc_mem_in_sandbox;

pub fn sandbox_impl(input: ItemFn) -> TokenStream {
    let function_signature = input.sig;
    let function_name = function_signature.ident;

    let invoke_sandbox_function_name_c = format!("invoke_sandbox_{}_c", function_name);
    let invoke_sandbox_function_name_c = Ident::new(&invoke_sandbox_function_name_c, function_name.span());

    let function_name_sandbox = format!("{}_sandbox", function_name);
    let function_name_sandbox = Ident::new(&function_name_sandbox, function_name.span());

    let function_name_sandbox_free = format!("{}_sandbox_free", function_name);
    let function_name_sandbox_free = Ident::new(&function_name_sandbox_free, function_name.span());

    // Reject illegal functions.
    if function_signature.asyncness.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot be async"));
    }
    if function_signature.unsafety.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot be unsafe"));
    }
    if function_signature.abi.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot be abi"));
    }
    if function_signature.generics.lt_token.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot have generics"));
    }
    if function_signature.variadic.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot be variadic"));
    }

    // Find arguments and return types.
    let params: Vec<_> = function_signature.inputs.iter().collect();
    if params.len() != 1 {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function must have exactly one Serializable argument"));
    }
    let arg = match params[0] {
        FnArg::Receiver(_) => {
            return quote_spanned!(function_name.span() => compile_error!("Sandbox function should not take self"));
        },
        FnArg::Typed(ty) => *ty.ty.clone(),
    };
    let ret = match function_signature.output {
        ReturnType::Default => {
            return quote_spanned!(function_name.span() => compile_error!("Sandbox function must return a Serializable type"));
        },
        ReturnType::Type(_, ty) => *ty.clone(),
    };

    quote! {
        #[cfg(not(target_arch = "wasm32"))]
        extern "C" {
            pub fn #invoke_sandbox_function_name_c(arg: *mut std::ffi::c_void, size: u32) -> ::alohomora_sandbox::sandbox_out;
        }

        // This should be generated by a macro.
        #[cfg(not(target_arch = "wasm32"))]
        #[allow(non_camel_case_types)]
        pub struct #function_name {}

        #[cfg(not(target_arch = "wasm32"))]
        #[doc = "Library implementation of AlohomoraSandbox. Do not copy this docstring!"]
        impl<'__a, '__b> alohomora_sandbox::AlohomoraSandbox<'__a, '__b, #arg, #ret> for #function_name {
            fn invoke(arg: #arg) -> ::alohomora_sandbox::FinalSandboxOut<#ret> {
                alohomora_sandbox::invoke_sandbox!(#invoke_sandbox_function_name_c, arg);
            }
        }

        // This should also be generated by macro.
        #[no_mangle]
        #[cfg(target_arch = "wasm32")]
        pub extern "C" fn #function_name_sandbox(arg: *mut std::ffi::c_void, size: u32) -> *mut u8{
            alohomora_sandbox::sandbox_preamble(#function_name, arg, size)
        }

        #[no_mangle]
        #[cfg(target_arch = "wasm32")]
        pub extern "C" fn #function_name_sandbox_free(ret: *mut ::std::os::raw::c_char) {
            use std::ffi::CString;
            let _ = unsafe { CString::from_raw(ret) };
        }
    }
}

pub type Error = (Span, &'static str);

pub fn derive_swizzleable_impl(input: DeriveInput) -> Result<TokenStream, Error> {
    let mut stream = TokenStream::new();

    // 1. define unswizzled type
    // 2. implement Swizzleable trait
    // 2a. define Unswizzled as unswizzled type from (1)
    // 2b. define unswizzle function
    //      

    if let syn::Data::Struct(struct_data) = input.data {
        let struct_name = input.ident.clone();
        let unswizzled_struct_name = Ident::new(&format!("{}Unswizzled", struct_name), struct_name.span());

        // panic!("{:?}", struct_data.fields);
        // set up the fields of the unswizzled version of this struct
        let mut unswizzled_fields = TokenStream::new();
        let mut unswizzle_function = TokenStream::new();
        let (outside_name, inside_name) = (Ident::new("outside", Span::call_site()), 
                                                         Ident::new("inside", Span::call_site()));
        match struct_data.fields.clone() {
            syn::Fields::Named(fields) => {
                for field in fields.named.iter() {
                    let field_name = field.ident.clone().unwrap();
                    // TODO: also fix usizes
                    if let syn::Type::Ptr(ptr) = &field.ty {
                        // if this field is a pointer, we make it a sandbox ptr
                        if let syn::Type::Path(p) = *ptr.elem.clone() {
                            let ptr_to_type = &p.path.segments.first().unwrap().ident;

                            let new_field = syn::Field::parse_named.parse2(
                                quote! { pub #field_name: SandboxPointer<<#ptr_to_type as Swizzleable>::Unswizzled> }
                            ).unwrap();
                            new_field.to_tokens(&mut unswizzled_fields);
                            unswizzled_fields.extend(quote!{,});            // add back comma bc we remove it when just getting the field

                            
                            let big_swizzle_line = quote!{
                                (*#inside_name).#field_name = 
                                    unswizzle_ptr(
                                    // ^^ unswizzle that pointer (to be in the sandbox)
                                        Swizzleable::unswizzle((*#outside_name).#field_name, 
                                        // ^^ unswizzle that whole data structure (to be in the sandbox)
                                            swizzle_ptr(&(*#inside_name).#field_name, #inside_name)));
                                            // ^^ first, swizzle the inside pointer to be global
                            };
                            unswizzle_function.extend(big_swizzle_line);
                        } else { return Err((input.ident.span(), "TODO")) }
                    } else {
                        // if not we keep as is
                        (*field).to_tokens(&mut unswizzled_fields);
                        unswizzled_fields.extend(quote!{,});                // add back comma bc we remove it when just getting the field


                        let function_copy_line = quote!{
                            (*#inside_name).#field_name = (*#outside_name).#field_name;
                        };
                        unswizzle_function.extend(function_copy_line);
                    }
                }
            }
            _ => return Err((input.ident.span(), "TODO")),
        }
        
        #[allow(non_snake_case)]
        let UNSWIZZLED_DEF = quote!{
            #[automatically_derived]
            #[derive(Debug)]
            pub struct #unswizzled_struct_name {
                #unswizzled_fields
            }
        };
        
        // create the function for implementing the trait
        
        // match struct_data.fields {
        //     syn::Fields::Named(fields) => {


        //     },
        //     _ => return Err((input.ident.span(), "TODO")),
        // }
        // for every field, if it's not a pointer we copy it

        // if it is a pointer, we 
        //    1. swizzle it, 
        //    2. recursively unswizzle the struct it points to, and then 
        //    3. unswizzle the pointer that gets returned 
        

        // implement the actual trait
        #[allow(non_snake_case)]
        let TRAIT_IMPL = quote!{
            #[automatically_derived]
            impl Swizzleable for #struct_name {
                type Unswizzled = #unswizzled_struct_name;
                unsafe fn unswizzle(outside: *mut Self, inside: *mut Self::Unswizzled) -> *mut Self::Unswizzled {
                    #unswizzle_function
                    println!("unswizzling from macro");
                    inside
                }
            }
        };
    
        stream.extend(UNSWIZZLED_DEF);
        stream.extend(TRAIT_IMPL);
        return Ok(stream);
    } else {
        Err((input.ident.span(), "derive(Swizzleable) only works on structs"))
    }
}