extern crate proc_macro2;
extern crate quote;
extern crate syn;

use proc_macro2::TokenStream;
use quote::{quote, quote_spanned, ToTokens, TokenStreamExt};
use syn::{FnArg, Ident, ItemFn, ReturnType, Token};

pub fn sandbox_impl(input: ItemFn) -> TokenStream {
    let function_signature = input.sig;
    let function_name = function_signature.ident;

    let invoke_sandbox_function_name_c = format!("invoke_sandbox_{}_c", function_name);
    let invoke_sandbox_function_name_c = Ident::new(&invoke_sandbox_function_name_c, function_name.span());

    let function_name_sandbox = format!("{}_sandbox", function_name);
    let function_name_sandbox = Ident::new(&function_name_sandbox, function_name.span());

    // Reject illegal functions.
    if function_signature.asyncness.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot be async"));
    }
    if function_signature.unsafety.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot be unsafe"));
    }
    if function_signature.abi.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot be abi"));
    }
    if function_signature.generics.lt_token.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot have generics"));
    }
    if function_signature.variadic.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot be variadic"));
    }

    // Find arguments and return types.
    let params: Vec<_> = function_signature.inputs.iter().collect();
    if params.len() != 1 {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function must have exactly one `SandboxTransfer` argument"));
    }
    let arg = match params[0] {
        FnArg::Receiver(_) => {
            return quote_spanned!(function_name.span() => compile_error!("Sandbox function should not take self"));
        },
        FnArg::Typed(ty) => *ty.ty.clone(),
    };
    let ret = match function_signature.output {
        ReturnType::Default => {
            return quote_spanned!(function_name.span() => compile_error!("Sandbox function must return a `SandboxTransfer` type"));
        },
        ReturnType::Type(_, ty) => *ty.clone(),
    };

    quote! {
        #[cfg(not(target_arch = "wasm32"))]
        extern "C" {
            pub fn #invoke_sandbox_function_name_c(arg: *mut std::ffi::c_void, sandbox: usize) -> *mut std::ffi::c_void;
        }

        // This should be generated by a macro.
        #[allow(non_camel_case_types)]
        pub struct #function_name {}

        #[doc = "Library implementation of AlohomoraSandbox. Do not copy this docstring!"]
        impl ::alohomora_sandbox::AlohomoraSandbox<#arg, #ret> for #function_name {
            /// The actual sandbox function.
            #[cfg(target_arch = "wasm32")]
            fn function(arg: #arg) -> #ret {
                #function_name(arg)
            }

            /// The FFI function responsible for invoking this sandbox.
            #[cfg(not(target_arch = "wasm32"))]
            fn ffi(arg: *mut std::ffi::c_void, sandbox: usize) -> *mut std::ffi::c_void {
                unsafe { #invoke_sandbox_function_name_c(arg, sandbox) }
            }
        }

        #[no_mangle]
        #[cfg(target_arch = "wasm32")]
        pub extern "C" fn #function_name_sandbox(arg: *mut std::ffi::c_void) -> *mut std::ffi::c_void {
            <#function_name as ::alohomora_sandbox::AlohomoraSandbox<#arg, #ret>>::sandbox_preamble(arg)
        }
    }
}

pub fn derive_fast_transfer_impl(
    input: syn::DeriveInput
) -> Result<TokenStream, (proc_macro2::Span, &'static str)> {
    // Check the macro is being used on a struct
    let struct_data = match input.data.clone() {
        syn::Data::Struct(s) => s,
        _ => return Err((input.ident.span(), "the `FastTransfer` trait can only be derived for structs")),
    };

    let fields = match struct_data.fields.clone() {
        syn::Fields::Named(f) => f,
        _ => return Err((input.ident.span(), "fields must be named")),
    };

    // Check all fields are public
    for field in fields.named.clone() {
        match field.vis {
            syn::Visibility::Public(_) => (),
            _ => return Err((field.ident.unwrap_or(input.ident).span(), "all fields must be public for `FastTransfer` types")),
        }
    }

    // Make sure they're using #[repr(C)]
    let mut uses_repr_c = false;
    for attr in input.attrs {
        if format!("{}", attr.to_token_stream()) == format!("#[repr(C)]") { uses_repr_c = true; }
    }
    if !uses_repr_c {
        return Err((input.ident.span(), "`FastTransfer` structs must use the `#[repr(C)]` attribute for a consistent memory layout"));
    }

    let struct_name = input.ident.clone();
    let unswizzled_name = Ident::new(&(struct_name.to_string() + "Unswizzled"), struct_name.span());

    let (impl_generics, type_generics, where_clause) = input.generics.split_for_impl();

    let field_name = fields.named.iter().map(|field| &field.ident);
    let field_type = fields.named.iter().map(|field| &field.ty);
    let field_name2 = fields.named.iter().map(|field| &field.ident);
    let field_name3 = fields.named.iter().map(|field| &field.ident);

    Ok(quote!{
        #[automatically_derived]
        #[cfg(not(target_arch = "wasm32"))] // the linker doesn't like having these structs for wasm2c
        #[repr(C)]
        pub struct #unswizzled_name #impl_generics #where_clause {
            #(pub #field_name: <#field_type as ::alohomora_sandbox::FastTransfer>::TypeInSandbox,)*
        }

        #[automatically_derived]
        #[doc = "Library implementation of FastSandboxTransfer. Do not copy this docstring!"]
        impl #impl_generics ::alohomora_sandbox::FastTransfer for #struct_name #type_generics #where_clause {
            #[cfg(not(target_arch = "wasm32"))]
            type TypeInSandbox = #unswizzled_name #type_generics;

            #[cfg(not(target_arch = "wasm32"))]
            fn into_sandbox(outside: Self, sandbox: ::alohomora_sandbox::SandboxInstance) -> Self::TypeInSandbox {
                #unswizzled_name {
                    #(#field_name2: ::alohomora_sandbox::FastTransfer::into_sandbox(outside.#field_name2, sandbox),)*
                }
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn out_of_sandbox(inside: &Self::TypeInSandbox, sandbox: ::alohomora_sandbox::SandboxInstance) -> Self {
                #struct_name {
                    #(#field_name3: ::alohomora_sandbox::FastTransfer::out_of_sandbox(&inside.#field_name3, sandbox),)*
                }
            }
        }
    })
}
