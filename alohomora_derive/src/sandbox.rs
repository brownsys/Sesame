extern crate proc_macro2;
extern crate quote;
extern crate syn;

use proc_macro2::TokenStream;
use quote::{quote, quote_spanned, ToTokens, TokenStreamExt};
use syn::{FnArg, Ident, ItemFn, ReturnType, Token};
// use ::alohomora_sandbox::alloc_mem_in_sandbox;

pub fn sandbox_impl(input: ItemFn) -> TokenStream {
    let function_signature = input.sig;
    let function_name = function_signature.ident;

    let invoke_sandbox_function_name_c = format!("invoke_sandbox_{}_c", function_name);
    let invoke_sandbox_function_name_c = Ident::new(&invoke_sandbox_function_name_c, function_name.span());

    let function_name_sandbox = format!("{}_sandbox", function_name);
    let function_name_sandbox = Ident::new(&function_name_sandbox, function_name.span());

    let function_name_sandbox_free = format!("{}_sandbox_free", function_name);
    let function_name_sandbox_free = Ident::new(&function_name_sandbox_free, function_name.span());

    // Reject illegal functions.
    if function_signature.asyncness.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot be async"));
    }
    if function_signature.unsafety.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot be unsafe"));
    }
    if function_signature.abi.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot be abi"));
    }
    if function_signature.generics.lt_token.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot have generics"));
    }
    if function_signature.variadic.is_some() {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function cannot be variadic"));
    }

    // Find arguments and return types.
    let params: Vec<_> = function_signature.inputs.iter().collect();
    if params.len() != 1 {
        return quote_spanned!(function_name.span() => compile_error!("Sandbox function must have exactly one Sandboxable argument"));
    }
    let arg = match params[0] {
        FnArg::Receiver(_) => {
            return quote_spanned!(function_name.span() => compile_error!("Sandbox function should not take self"));
        },
        FnArg::Typed(ty) => *ty.ty.clone(),
    };
    let ret = match function_signature.output {
        ReturnType::Default => {
            return quote_spanned!(function_name.span() => compile_error!("Sandbox function must return a Sandboxable type"));
        },
        ReturnType::Type(_, ty) => *ty.clone(),
    };

    quote! {
        #[cfg(not(target_arch = "wasm32"))]
        extern "C" {
            pub fn #invoke_sandbox_function_name_c(arg: *mut std::ffi::c_void, slot: usize) -> ::alohomora_sandbox::sandbox_out;
        }

        // This should be generated by a macro.
        #[cfg(not(target_arch = "wasm32"))]
        #[allow(non_camel_case_types)]
        pub struct #function_name {}

        #[cfg(not(target_arch = "wasm32"))]
        #[doc = "Library implementation of AlohomoraSandbox. Do not copy this docstring!"]
        impl<'__a, '__b> alohomora_sandbox::AlohomoraSandbox<'__a, '__b, #arg, #ret> for #function_name {
            fn invoke(arg: <#arg as ::alohomora_sandbox::Sandboxable>::InSandboxUnswizzled, sandbox_index: usize) -> #ret {
                alohomora_sandbox::invoke_sandbox!(#invoke_sandbox_function_name_c, arg, #arg, #ret, sandbox_index);
            }
        }

        // This should also be generated by macro.
        #[no_mangle]
        #[cfg(target_arch = "wasm32")]
        pub extern "C" fn #function_name_sandbox(arg: *mut std::ffi::c_void) -> *mut std::ffi::c_void {
            alohomora_sandbox::sandbox_preamble(#function_name, arg)
        }

        #[no_mangle]
        #[cfg(target_arch = "wasm32")]
        pub extern "C" fn #function_name_sandbox_free(ret: *mut ::std::os::raw::c_char) {
            use std::ffi::CString;
            let _ = unsafe { CString::from_raw(ret) };
        }
    }
}

pub type Error = (proc_macro2::Span, &'static str);

pub fn derive_sandboxable_impl(input: syn::DeriveInput) -> Result<TokenStream, Error> {
    let mut stream = TokenStream::new();

    // Check the macro is being used on a struct
    let struct_data = match input.data.clone() {
        syn::Data::Struct(s) => s,
        _ => return Err((input.ident.span(), "the `Sandboxable` trait can only be derived for structs")),
    };

    let fields = match struct_data.fields.clone() {
        syn::Fields::Named(f) => f,
        _ => return Err((input.ident.span(), "fields must be named")),
    };

    // Check all fields are public
    for field in fields.named.clone() {
        match field.vis {
            syn::Visibility::Public(_) => (),
            _ => return Err((field.ident.unwrap_or(input.ident).span(), "all fields must be public for `Sandboxable` types")),
        }
    }

    // Make sure they're using #[repr(C)]
    let mut uses_repr_c = false;
    for attr in input.attrs {
        if format!("{}", attr.to_token_stream()) == format!("#[repr(C)]") { uses_repr_c = true; }
    }
    if !uses_repr_c {
        return Err((input.ident.span(), "`Sandboxable` structs must use the `#[repr(C)]` attribute for a consistent memory layout"));
    }

    let struct_name = input.ident.clone();
    let unswizzled_name = Ident::new(&(struct_name.to_string() + "Unswizzled"), struct_name.span());

    let (impl_generics, type_generics, where_clause) = input.generics.split_for_impl();

    let field_name = fields.named.iter().map(|field| &field.ident);
    let field_type = fields.named.iter().map(|field| &field.ty);
    let field_name2 = fields.named.iter().map(|field| &field.ident);
    let field_name3 = fields.named.iter().map(|field| &field.ident);

    let q = quote!{
        #[automatically_derived]
        #[cfg(not(target_arch = "wasm32"))] // the linker doesn't like having these structs for wasm2c
        #[repr(C)]
        pub struct #unswizzled_name #impl_generics #where_clause {
            #(pub #field_name: <#field_type as ::alohomora_sandbox::Sandboxable>::InSandboxUnswizzled,)*
        }

        #[automatically_derived]
        #[cfg(not(target_arch = "wasm32"))]
        impl #impl_generics ::alohomora_sandbox::Sandboxable for #struct_name #type_generics #where_clause {
            type InSandboxUnswizzled = #unswizzled_name #type_generics;
            fn into_sandbox(outside: Self, alloc: ::alohomora_sandbox::alloc::SandboxAllocator) -> Self::InSandboxUnswizzled {
                #unswizzled_name {
                    #(#field_name2: ::alohomora_sandbox::Sandboxable::into_sandbox(outside.#field_name2, alloc.clone()),)*
                }
            }
            fn out_of_sandbox(inside: &Self::InSandboxUnswizzled, any_sandbox_ptr: usize) -> Self {
                #struct_name {
                #(#field_name3: ::alohomora_sandbox::Sandboxable::out_of_sandbox(&inside.#field_name3, any_sandbox_ptr),)*
                }
            }
        }
    };

    stream.extend(q);
    Ok(stream)
}