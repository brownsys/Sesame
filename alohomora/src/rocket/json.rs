use std::collections::HashMap;
use std::ops::{Deref, DerefMut};
use rocket::data::ByteUnit;
use rocket::response::Responder;
use rocket::serde::json::Json;
use serde_json::{Value, Map};

use crate::bbox::BBox;
use crate::context::{Context, ContextData, UnprotectedContext};
use crate::policy::{AnyPolicy, FrontendPolicy, Policy, Reason};
use crate::rocket::{BBoxData, BBoxDataOutcome, BBoxRequest, BBoxResponder, BBoxResponse, BBoxResponseResult, FromBBoxData};

// Wrapper around serde_json::Value created from requests and consumed by our types.
pub struct InputBBoxValue {
    value: Value,
}
impl InputBBoxValue {
    pub fn new(value: Value) -> Self {
        Self { value }
    }
    pub fn is_null(&self) -> bool {
        self.value.is_null()
    }
    pub fn into_array(self) -> Result<Vec<InputBBoxValue>, &'static str> {
        match self.value {
            Value::Array(vec) => Ok(vec
                .into_iter()
                .map(InputBBoxValue::new)
                .collect()
            ),
            _ => Err("Bad JSON"),
        }
    }
    pub fn into_object(self) -> Result<HashMap<String, InputBBoxValue>, &'static str> {
        match self.value {
            Value::Object(map) => Ok(map
                .into_iter()
                .map(|(key, value)| (key, InputBBoxValue::new(value)))
                .collect()
            ),
            _ => Err("Bad JSON"),
        }
    }
    pub fn into_bool<P: FrontendPolicy>(self, request: BBoxRequest<'_, '_>) -> Result<BBox<bool, P>, &'static str> {
        match self.value {
            Value::Bool(bool) => Ok(BBox::new(bool, P::from_request(request.get_request()))),
            _ => Err("Bad JSON"),
        }
    }
    pub fn into_string<P: FrontendPolicy>(self, request: BBoxRequest<'_, '_>) -> Result<BBox<String, P>, &'static str> {
        match self.value {
            Value::String(string) => Ok(BBox::new(string, P::from_request(request.get_request()))),
            _ => Err("Bad JSON"),
        }
    }
    pub fn into_i64<P: FrontendPolicy>(self, request: BBoxRequest<'_, '_>) -> Result<BBox<i64, P>, &'static str> {
        match self.value {
            Value::Number(number) => match number.as_i64() {
                Some(number) => Ok(BBox::new(number, P::from_request(request.get_request()))),
                None => Err("Bad JSON"),
            },
            _ => Err("Bad JSON"),
        }
    }
    pub fn into_u64<P: FrontendPolicy>(self, request: BBoxRequest<'_, '_>) -> Result<BBox<u64, P>, &'static str> {
        match self.value {
            Value::Number(number) => match number.as_u64() {
                Some(number) => Ok(BBox::new(number, P::from_request(request.get_request()))),
                None => Err("Bad JSON"),
            },
            _ => Err("Bad JSON"),
        }
    }
    pub fn into_f64<P: FrontendPolicy>(self, request: BBoxRequest<'_, '_>) -> Result<BBox<f64, P>, &'static str> {
        match self.value {
            Value::Number(number) => match number.as_f64() {
                Some(number) => Ok(BBox::new(number, P::from_request(request.get_request()))),
                None => Err("Bad JSON"),
            },
            _ => Err("Bad JSON"),
        }
    }
}

// Wrapper around serde_json::Value generated by our types and consumed during responses.
pub enum OutputBBoxValue {
    BBox(BBox<Value, AnyPolicy>),
    Value(Value),
    Array(Vec<OutputBBoxValue>),
    Object(HashMap<String, OutputBBoxValue>),
}
impl OutputBBoxValue {
    // Not public, not exposed to applications.
    fn transform(self, context: &UnprotectedContext) -> Result<Value, &'static str> {
        match self {
            OutputBBoxValue::BBox(bbox) => {
                if bbox.policy().check(context, Reason::Response) {
                    Ok(bbox.consume().0)
                } else {
                    Err("Policy check failed")
                }
            },
            OutputBBoxValue::Value(value) => Ok(value),
            OutputBBoxValue::Array(vec) => {
                let mut v = Vec::with_capacity(vec.len());
                for val in vec {
                    v.push(val.transform(context)?);
                }
                Ok(Value::Array(v))
            },
            OutputBBoxValue::Object(map) => {
                let mut m = Map::with_capacity(map.len());
                for (key, val) in map {
                    m.insert(key, val.transform(context)?);
                }
                Ok(Value::Object(m))
            },
        }
    }
}

// Trait for transformation between JSON data and structs.
pub trait FromBBoxJson {
    fn from_json(value: InputBBoxValue, request: BBoxRequest<'_, '_>) -> Result<Self, &'static str>
        where
            Self: Sized;
    fn to_json(self) -> Result<OutputBBoxValue, &'static str>;
}

// Can use this as an argument or return this from route functions.
pub struct BBoxJson<T: FromBBoxJson>(pub T);
impl<T: FromBBoxJson> BBoxJson<T> {
    pub fn into_inner(self) -> T {
        self.0
    }
}
impl<T: FromBBoxJson> Deref for BBoxJson<T> {
    type Target = T;
    #[inline(always)]
    fn deref(&self) -> &T {
        &self.0
    }
}
impl<T: FromBBoxJson> DerefMut for BBoxJson<T> {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut T {
        &mut self.0
    }
}

async fn parse_body<'a, 'r>(r: BBoxRequest<'a, 'r>, d: BBoxData<'a>) -> Result<String, &'static str> {
    let size_limit = r.get_request().limits().get("json").unwrap_or(ByteUnit::Mebibyte(1));
    match d.get_data().open(size_limit).into_string().await {
        Ok(string) => Ok(string.into_inner()),
        Err(_) => Err("Request data is incomplete"),
    }
}

// Allows us to use this as a data parameter in routes.
#[rocket::async_trait]
impl<'a, 'r, T: FromBBoxJson> FromBBoxData<'a, 'r> for BBoxJson<T> {
    type BBoxError = &'static str;

    async fn from_data(req: BBoxRequest<'a, 'r>, data: BBoxData<'a>) -> BBoxDataOutcome<'a, 'r, Self> {
        match parse_body(req, data).await {
            Err(e) => BBoxDataOutcome::Failure((rocket::http::Status::BadRequest, e)),
            Ok(json_string) => match serde_json::from_str(&json_string) {
                Ok(v) => match T::from_json(InputBBoxValue::new(v), req) {
                    Ok(t) => BBoxDataOutcome::Success(BBoxJson(t)),
                    Err(e) => BBoxDataOutcome::Failure((rocket::http::Status::BadRequest, e))
                },
                Err(_) => BBoxDataOutcome::Failure((rocket::http::Status::BadRequest, "Request data is not JSON")),
            }
        }
    }
}

// Endpoints can return (T: FromBBoxJson, Context) which Alohomora eventually turns into
// T after a policy check.
pub struct JsonResponse<T: FromBBoxJson, D: ContextData>(pub T, pub Context<D>);
impl<T: FromBBoxJson, D: ContextData> From<(T, Context<D>)> for JsonResponse<T, D> {
    fn from((json, context): (T, Context<D>)) -> Self {
        Self(json, context)
    }
}

impl<'a, 'r, 'o: 'a, T: FromBBoxJson, D: ContextData> BBoxResponder<'a, 'r, 'o> for JsonResponse<T, D> {
    fn respond_to(self, request: BBoxRequest<'a, 'r>) -> BBoxResponseResult<'o> {
        let (json, context) = (self.0, self.1);
        let context = UnprotectedContext::from(context);

        match json.to_json() {
            Err(_) => Err(rocket::http::Status { code: 521 }),
            Ok(json) => {
                match json.transform(&context) {
                    Err(_) => Err(rocket::http::Status {code: 555 }),
                    Ok(json) => {
                        let x = Json(json);
                        match <Json<Value> as Responder>::respond_to(x, request.get_request()) {
                            Ok(response) => Ok(BBoxResponse::new(response)),
                            Err(e) => Err(e),
                        }
                    },
                }
            }
        }
    }
}