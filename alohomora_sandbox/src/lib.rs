#![feature(allocator_api)]
pub extern crate bincode;
pub extern crate serde;
pub extern crate serde_json;

use std::{ffi::c_uint, marker::PhantomData, os::raw::c_void};
use alloc::AllocateableInSandbox;
use serde::{Serialize, Deserialize};
use swizzle::Swizzleable;

pub mod ptr;
pub mod swizzle;
pub mod alloc;
pub mod vec;

// Used inside the sandbox for serializing/deserializing arguments and results.
#[cfg(target_arch = "wasm32")]
pub fn sandbox_preamble<'a, T, R: Serialize, F: Fn(T) -> R>(
    // TODO:                ^^ T should be Swizzlable
    functor: F, arg: *mut std::ffi::c_void, len: u32) -> *mut u8 {
    use std::slice;
    use std::mem;

    // Deserialize input.
    // let bytes = unsafe { slice::from_raw_parts(arg, len as usize) };
    // let arg = bincode::deserialize(bytes).unwrap();

    // Call function.
    let ptr = arg as *mut T;
    
    let ret = unsafe { 
        let b = Box::from_raw(ptr);
        functor(*b)
    };
    

    // Serialize output.
    let mut ret = bincode::serialize(&ret).unwrap();
    let size = ret.len() as u16;
    let size_1 = (size / 100) as u8;
    let size_2 = (size % 100) as u8;
    let mut vec2 = Vec::with_capacity(ret.len() + 2);
    vec2.push(size_1);
    vec2.push(size_2);
    for x in ret {
        vec2.push(x);
    }
    let ptttr = vec2.as_mut_ptr();
    mem::forget(vec2);
    ptttr
}

// Trait that sandboxed functions should implement.
pub trait AlohomoraSandbox<'a, 'b, T, R> 
    where 
        T: Clone + Swizzleable + AllocateableInSandbox,
        R: Serialize + Deserialize<'b>
{
    fn invoke(arg: T) -> FinalSandboxOut<R>;
}
// pub trait AlohomoraSandbox2<'a, 'b, T: Serialize + Deserialize<'a>, R: Serialize + Deserialize<'b>> {
//     fn invoke(arg: T) -> FinalSandboxOut<R>;
// }

// This should be generated by a macro.
#[cfg(not(target_arch = "wasm32"))]
extern "C" {
    pub fn invoke_free_c(arg1: *mut u8);
}

#[cfg(not(target_arch = "wasm32"))]
#[repr(C)]
pub struct sandbox_out {
    pub result: *mut u8,
    pub size: u32,
    pub setup: ::std::os::raw::c_ulonglong,
    pub teardown: ::std::os::raw::c_ulonglong,
}

pub struct FinalSandboxOut<R> {
    pub result: R,
    pub size: u32,
    pub setup: u64,
    pub teardown: u64,
}

// take a pointer to the vector and add all the shit
// pub extern "C" fn transfer_arg(arg: Box<Vec<(f64, u64)>>, sandbox_loc: &mut Box<Vec<(f64, u64)>>) -> bool {
// #[cfg(target_arch = "wasm32")]
extern "C" {
    pub fn alloc_mem_in_sandbox(size: usize, sandbox: usize) -> *mut std::ffi::c_void;
    pub fn free_mem_in_sandbox(ptr: *mut std::ffi::c_void, sandbox: usize);
}

// 1. swizzle it out
// 2. do our modifications on the data type
// 3. make sure we swizzle back all pointers in the data type

// Called by Alohomora (from the application process) to invoke the sandbox.
#[macro_export]
macro_rules! invoke_sandbox {
    ($functor:ident, $arg:ident, $arg_ty:ty) => {
        // Serialize argument.
        // let v: Vec<u8> = ::alohomora_sandbox::bincode::serialize(&$arg).unwrap();
        // let arg = ::alohomora_sandbox::serde_json::to_string(&$arg).unwrap();
        // let arg = ::std::ffi::CString::new(arg).unwrap();
        // let input_vec: *mut Vec<(f64, u64)> = $arg as *mut Vec<(f64, u64)>;

        // 1. get lock on a sandbox (TODO: do it for real)
        let sandbox = 0;
        // 2. make custom allocator for that sandbox
        let alloc = ::alohomora_sandbox::alloc::SandboxAllocator::new(sandbox);

        // println!("***the arg is {:?} w type {:?}", $arg, stringify!($arg_ty));
        
        let outside_ptr = (&$arg as *const $arg_ty) as *mut $arg_ty;
        // ^^ could also put in a box to get ptr but keeping old should be faster

        // 3. use custom allocator to allocate it with same shape as `outside_ptr`
        let inside_ptr: *mut $arg_ty = unsafe {
            let p = ::alohomora_sandbox::alloc::AllocateableInSandbox::allocate_in_sandbox(outside_ptr, alloc);
            p as *mut $arg_ty
        };

        // 4. swizzle them into the new memory
        let new_inside_ptr = unsafe {
            let fake_old_inside = (*inside_ptr).clone();

            println!("inside (in sandbox) is {:?}", (&*inside_ptr));
            println!("outside (out of sandbox) is len {:?} cap {:?}", (*outside_ptr).len(), (*outside_ptr).capacity());

            println!("unswizzling it (so changes are reflected in sandbox)");

            let new = ::alohomora_sandbox::swizzle::Swizzleable::unswizzle(outside_ptr, inside_ptr, &fake_old_inside);
            
            println!("inside is now {:?}", (&*inside_ptr));
            new
        };
        
        // Invoke sandbox via C.
        println!("*entering FUNCTOR");
        let ret2: ::alohomora_sandbox::sandbox_out = unsafe { $functor(new_inside_ptr as *mut std::ffi::c_void, 0) };

        println!("*just finished some macro business");
        let ret = ret2.result;

        // Deserialize output.
        let bytes = unsafe {std::slice::from_raw_parts(ret, ret2.size as usize)};
        let result = ::alohomora_sandbox::bincode::deserialize(bytes).unwrap();

        // Free memory.
        unsafe { ::alohomora_sandbox::invoke_free_c(ret) };

        // Return.
        return ::alohomora_sandbox::FinalSandboxOut { result: result, size: ret2.size, setup: ret2.setup, teardown: ret2.teardown };
    }
}
