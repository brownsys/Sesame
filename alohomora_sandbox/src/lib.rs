#![feature(allocator_api)]
pub extern crate bincode;
pub extern crate serde;
pub extern crate serde_json;

use serde::{Serialize, Deserialize};
use copy::Swizzleable;

pub mod ptr;
pub mod vec;
pub mod vec_impl;
pub mod copy;
pub mod alloc;

// Used inside the sandbox for serializing/deserializing arguments and results.
#[cfg(target_arch = "wasm32")]
pub fn sandbox_preamble<'a, T: std::fmt::Debug, R: Swizzleable, F: Fn(T) -> R>(
    functor: F, arg: *mut std::ffi::c_void) -> *mut std::ffi::c_void {
    use std::slice;
    use std::mem;

    // Convert arg to a pointer of the right type.
    let ptr = arg as *mut T;
    
    let ret = unsafe { 
        // Put it into a box so we can get ownership
        let b = Box::from_raw(ptr);
        
        // Call the actual function
        functor(*b)
    };

    // Put the output into a box
    let b = Box::new(ret);
    Box::into_raw(b)

    // Serialize output.
    // let mut ret = bincode::serialize(&ret).unwrap();
    // let size = ret.len() as u16;
    // let size_1 = (size / 100) as u8;
    // let size_2 = (size % 100) as u8;
    // let mut vec2 = Vec::with_capacity(ret.len() + 2);
    // vec2.push(size_1);
    // vec2.push(size_2);
    // for x in ret {
    //     vec2.push(x);
    // }
    // let ptttr = vec2.as_mut_ptr();
    // mem::forget(vec2);
    // ptttr
}

// Trait that sandboxed functions should implement.
pub trait AlohomoraSandbox<'a, 'b, T, R> 
    where 
        T: Swizzleable,
        R: Serialize + Deserialize<'b>
{
    fn invoke(arg: <T as Swizzleable>::Unswizzled, sandbox_index: usize) -> FinalSandboxOut<R>;
}

// This should be generated by a macro.
#[cfg(not(target_arch = "wasm32"))]
extern "C" {
    pub fn invoke_free_c(arg1: *mut u8);
}

#[cfg(not(target_arch = "wasm32"))]
#[repr(C)]
pub struct sandbox_out {
    pub result: *mut u8,
    pub size: u32,
    pub setup: ::std::os::raw::c_ulonglong,
    pub teardown: ::std::os::raw::c_ulonglong,
}

pub struct FinalSandboxOut<R> {
    pub result: R,
    pub size: u32,
    pub setup: u64,
    pub teardown: u64,
}

// #[cfg(target_arch = "wasm32")]
extern "C" {
    pub fn alloc_mem_in_sandbox(size: usize, sandbox: usize) -> *mut std::ffi::c_void;
    pub fn free_mem_in_sandbox(ptr: *mut std::ffi::c_void, sandbox: usize);
    pub fn get_lock_on_sandbox() -> usize;
    pub fn unlock_sandbox(index: usize);
}

// Called by Alohomora (from the application process) to invoke the sandbox.
#[macro_export]
macro_rules! invoke_sandbox {
    ($functor:ident, $arg:ident, $arg_ty:ty, $ret_ty:ty, $sandbox_index:ident) => {

        // `$arg` is already a swizzled 32 bit type for the sandbox, 
        // so we just make a raw pointer for passing through 'C land' 
        // then the preamble can reconstruct the real type back in Rust
        let new_inside_ptr = Box::into_raw(Box::new_in($arg, ::alohomora_sandbox::alloc::SandboxAllocator::new($sandbox_index)));
        
        // Invoke sandbox via C.
        let ret2: ::alohomora_sandbox::sandbox_out = unsafe { $functor(new_inside_ptr as *mut std::ffi::c_void, $sandbox_index) };
        let ret = ret2.result;

        // Construct back object from pointer

        let b = unsafe{ Box::from_raw(ret as *mut <$ret_ty as ::alohomora_sandbox::copy::Swizzleable>::Unswizzled) };
        let result_unswizzled = *b;

        // Swizzle it back
        let result = unsafe { Swizzleable::swizzle(result_unswizzled) };

        // Deserialize output.
        // let bytes = unsafe {std::slice::from_raw_parts(ret, ret2.size as usize)};
        // let result = ::alohomora_sandbox::bincode::deserialize(bytes).unwrap();

        // // Free memory.
        // unsafe { ::alohomora_sandbox::invoke_free_c(ret) };

        // Return.
        return ::alohomora_sandbox::FinalSandboxOut { result: result, size: ret2.size, setup: ret2.setup, teardown: ret2.teardown };
    }
}
